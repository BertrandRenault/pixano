import Konva from "konva";
import type { Mask, BBox } from "@pixano/core";

import { BBOX_STROKEWIDTH, MASK_STROKEWIDTH } from "../lib/constants";
import type { Tool } from "../tools";

export const toggleIsEditingBBox = (
  value: "on" | "off",
  stage: Konva.Stage,
  currentBox: BBox,
  bboxes: BBox[],
) => {
  const rect = stage.findOne(`#rect${currentBox.id}`);
  rect.draggable(value === "on");
  const tooltip = stage.findOne(`#tooltip${currentBox.id}`);
  tooltip.opacity(value === "on" ? 0 : 1);
  if (value === "off") {
    tooltip.x(rect.x());
    tooltip.y(rect.y());
  }
  const transformer: Konva.Transformer = stage.findOne("#transformer");
  transformer.nodes(value === "on" ? [rect] : []);
  return bboxes.map((bbox) => {
    if (bbox.id === currentBox.id) {
      bbox.editing = value === "on";
    }
    return bbox;
  });
};

export function addBBox(
  bbox: BBox,
  color: string,
  bboxGroup: Konva.Group,
  image: Konva.Image,
  viewId: string,
  zoomFactor: Record<string, number>,
  mutateBboxes: (val: "on" | "off") => void,
) {
  const x = image.x() + bbox.bbox[0];
  const y = image.y() + bbox.bbox[1];
  const rect_width = bbox.bbox[2];
  const rect_height = bbox.bbox[3];

  const bboxKonva = new Konva.Group({
    id: bbox.id,
    visible: bbox.visible,
    opacity: bbox.opacity,
  });

  const bboxRect = new Konva.Rect({
    id: `rect${bbox.id}`,
    x: x,
    y: y,
    width: rect_width,
    height: rect_height,
    stroke: color,
    strokeWidth: BBOX_STROKEWIDTH / zoomFactor[viewId],
  });
  bboxKonva.add(bboxRect);

  // Create a tooltip for bounding box category and confidence
  const tooltip = new Konva.Label({
    id: `tooltip${bbox.id}`,
    x,
    y,
    offsetY: 18,
    scale: {
      x: 1 / zoomFactor[viewId],
      y: 1 / zoomFactor[viewId],
    },
  });

  // Add a tag
  tooltip.add(
    new Konva.Tag({
      fill: color,
      stroke: color,
    }),
  );

  // Add text
  tooltip.add(
    new Konva.Text({
      x: x,
      y: y,
      text: bbox.tooltip,
      fontSize: 18,
      fontFamily: "DM Sans",
      padding: 0,
    }),
  );

  // Add to group
  bboxKonva.add(tooltip);
  bboxGroup.add(bboxKonva);

  bboxRect.on("click", function (e) {
    e.cancelBubble = true;
    mutateBboxes("on");
  });
  bboxRect.on("transformend", function () {
    mutateBboxes("off");
  });
}

export function addMask(
  mask: Mask,
  color: string,
  maskGroup: Konva.Group,
  image: Konva.Image,
  viewId: string,
  stage: Konva.Stage,
  zoomFactor: Record<string, number>,
) {
  const x = image.x();
  const y = image.y();
  const scale = image.scale();

  const style = new Option().style;
  style.color = color;

  //utility functions to extract coords from SVG
  //works only with SVG format "Mx0 y0 Lx1 y1 ... xn yn"
  // --> format generated by convertSegmentsToSVG
  function m_part(svg: string) {
    const splits = svg.split(" ");
    const x = splits[0].slice(1); //remove "M"
    return { x: parseInt(x), y: parseInt(splits[1]) };
  }
  function l_part(svg: string) {
    const splits = svg.split(" ");
    const x0 = splits[2].slice(1); //remove "L"
    const res = [{ x: parseInt(x0), y: parseInt(splits[3]) }];
    for (let i = 4; i < splits.length; i += 2) {
      res.push({
        x: parseInt(splits[i]),
        y: parseInt(splits[i + 1]),
      });
    }
    return res;
  }
  const maskKonva = new Konva.Shape({
    id: mask.id,
    x: x,
    y: y,
    width: stage.width(),
    height: stage.height(),
    fill: `rgba(${style.color.replace("rgb(", "").replace(")", "")}, 0.35)`,
    stroke: style.color,
    strokeWidth: MASK_STROKEWIDTH / zoomFactor[viewId],
    scale: scale,
    visible: mask.visible,
    opacity: mask.opacity,
    listening: false,
    sceneFunc: (ctx, shape) => {
      ctx.beginPath();
      for (let i = 0; i < mask.svg.length; ++i) {
        const start = m_part(mask.svg[i]);
        ctx.moveTo(start.x, start.y);
        const l_pts = l_part(mask.svg[i]);
        for (const pt of l_pts) {
          ctx.lineTo(pt.x, pt.y);
        }
      }
      ctx.fillStrokeShape(shape);
    },
  });
  maskGroup.add(maskKonva);
}

export function destroyDeletedObjects(objectsIds: Array<string>, objectsGroup: Konva.Group) {
  // Check if Object ID still exist in list. If not, object is deleted and must be removed from group
  const objectsToDestroy = []; // need to build a list to not destroy while looping children
  for (const obj of objectsGroup.children) {
    if (!objectsIds.includes(obj.id())) objectsToDestroy.push(obj);
  }
  for (const obj of objectsToDestroy) obj.destroy();
}

export function findOrCreateCurrentMask(viewId: string, stage: Konva.Stage): Konva.Group {
  const viewLayer: Konva.Layer = stage.findOne(`#${viewId}`);

  const currentAnnGroup: Konva.Group = viewLayer.findOne("#currentAnnotation");

  // Get and update the current annotation masks
  let currentMaskGroup: Konva.Group = currentAnnGroup.findOne("#currentMask");

  if (!currentMaskGroup) {
    currentMaskGroup = new Konva.Group({
      id: "currentMask",
    });
    currentAnnGroup.add(currentMaskGroup);
  }
  return currentMaskGroup;
}

export function clearCurrentAnn(viewId: string, stage: Konva.Stage, selectedTool: Tool) {
  const viewLayer: Konva.Layer = stage.findOne(`#${viewId}`);
  const currentAnnGroup: Konva.Group = viewLayer.findOne("#currentAnnotation");
  const currentMaskGroup: Konva.Group = currentAnnGroup.findOne("#currentMask");
  if (currentMaskGroup) currentMaskGroup.destroy();
  if (selectedTool.postProcessor) selectedTool.postProcessor.reset();
}
